% !TeX spellcheck = en_US
%% 字体：方正静蕾简体
%%		 方正粗宋
\documentclass[a4paper,left=2.5cm,right=2.5cm,11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{fontspec}
\usepackage{cite}
\usepackage{xeCJK}
\usepackage{indentfirst}
\usepackage{titlesec}
\usepackage{longtable}
\usepackage{graphicx}
\usepackage{float}
\usepackage{rotating}
\usepackage{subfigure}
\usepackage{tabu}
\usepackage{amsmath}
\usepackage{setspace}
\usepackage{amsfonts}
\usepackage{appendix}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\setcounter{secnumdepth}{4}
\usepackage{mhchem}
\usepackage{multirow}
\usepackage{extarrows}
\usepackage{hyperref}
\titleformat*{\section}{\LARGE}
\renewcommand\refname{参考文献}
\renewcommand{\abstractname}{\sihao \cjkfzcs 摘{  }要}
%\titleformat{\chapter}{\centering\bfseries\huge\wryh}{}{0.7em}{}{}
%\titleformat{\section}{\LARGE\bf}{\thesection}{1em}{}{}
\titleformat{\subsection}{\Large\bfseries}{\thesubsection}{1em}{}{}
\titleformat{\subsubsection}{\large\bfseries}{\thesubsubsection}{1em}{}{}
\renewcommand{\contentsname}{{\cjkfzcs \centerline{目{  } 录}}}
\setCJKfamilyfont{cjkhwxk}{STXingkai}
\setCJKfamilyfont{cjkfzcs}{STSongti-SC-Regular}
% \setCJKfamilyfont{cjkhwxk}{华文行楷}
% \setCJKfamilyfont{cjkfzcs}{方正粗宋简体}
\newcommand*{\cjkfzcs}{\CJKfamily{cjkfzcs}}
\newcommand*{\cjkhwxk}{\CJKfamily{cjkhwxk}}
\newfontfamily\wryh{Microsoft YaHei}
\newfontfamily\hwzs{STZhongsong}
\newfontfamily\hwst{STSong}
\newfontfamily\hwfs{STFangsong}
\newfontfamily\jljt{MicrosoftYaHei}
\newfontfamily\hwxk{STXingkai}
% \newfontfamily\hwzs{华文中宋}
% \newfontfamily\hwst{华文宋体}
% \newfontfamily\hwfs{华文仿宋}
% \newfontfamily\jljt{方正静蕾简体}
% \newfontfamily\hwxk{华文行楷}
\newcommand{\verylarge}{\fontsize{60pt}{\baselineskip}\selectfont}  
\newcommand{\chuhao}{\fontsize{44.9pt}{\baselineskip}\selectfont}  
\newcommand{\xiaochu}{\fontsize{38.5pt}{\baselineskip}\selectfont}  
\newcommand{\yihao}{\fontsize{27.8pt}{\baselineskip}\selectfont}  
\newcommand{\xiaoyi}{\fontsize{25.7pt}{\baselineskip}\selectfont}  
\newcommand{\erhao}{\fontsize{23.5pt}{\baselineskip}\selectfont}  
\newcommand{\xiaoerhao}{\fontsize{19.3pt}{\baselineskip}\selectfont} 
\newcommand{\sihao}{\fontsize{14pt}{\baselineskip}\selectfont}      % 字号设置  
\newcommand{\xiaosihao}{\fontsize{12pt}{\baselineskip}\selectfont}  % 字号设置  
\newcommand{\wuhao}{\fontsize{10.5pt}{\baselineskip}\selectfont}    % 字号设置  
\newcommand{\xiaowuhao}{\fontsize{9pt}{\baselineskip}\selectfont}   % 字号设置  
\newcommand{\liuhao}{\fontsize{7.875pt}{\baselineskip}\selectfont}  % 字号设置  
\newcommand{\qihao}{\fontsize{5.25pt}{\baselineskip}\selectfont}    % 字号设置 

\usepackage{diagbox}
\usepackage{multirow}
\boldmath
\XeTeXlinebreaklocale "zh"
\XeTeXlinebreakskip = 0pt plus 1pt minus 0.1pt
\definecolor{cred}{rgb}{0.8,0.8,0.8}
\definecolor{cgreen}{rgb}{0,0.3,0}
\definecolor{cpurple}{rgb}{0.5,0,0.35}
\definecolor{cdocblue}{rgb}{0,0,0.3}
\definecolor{cdark}{rgb}{0.95,1.0,1.0}
\lstset{
	language=bash,
	numbers=left,
	numberstyle=\tiny\color{black},
	showspaces=false,
	showstringspaces=false,
	basicstyle=\scriptsize,
	keywordstyle=\color{purple},
	commentstyle=\itshape\color{cgreen},
	stringstyle=\color{blue},
	frame=lines,
	% escapeinside=``,
	extendedchars=true, 
	xleftmargin=1em,
	xrightmargin=1em, 
	backgroundcolor=\color{cred},
	aboveskip=1em,
	breaklines=true,
	tabsize=4
} 

\newfontfamily{\consolas}{Consolas}
\newfontfamily{\monaco}{Monaco}
\setmonofont[Mapping={}]{Consolas}	%英文引号之类的正常显示，相当于设置英文字体
\setsansfont{Consolas} %设置英文字体 Monaco, Consolas,  Fantasque Sans Mono
\setmainfont{Times New Roman}

\setCJKmainfont{华文中宋}


\newcommand{\fic}[1]{\begin{figure}[H]
		\center
		\includegraphics[width=0.8\textwidth]{#1}
	\end{figure}}
	
\newcommand{\sizedfic}[2]{\begin{figure}[H]
		\center
		\includegraphics[width=#1\textwidth]{#2}
	\end{figure}}

\newcommand{\codefile}[1]{\lstinputlisting{#1}}

\newcommand{\interval}{\vspace{0.5em}}

\newcommand{\tablestart}{
	\interval
	\begin{longtable}{p{2cm}p{10cm}}
	\hline}
\newcommand{\tableend}{
	\hline
	\end{longtable}
	\interval}

% 改变段间隔
\setlength{\parskip}{0.2em}
\linespread{1.1}

\usepackage{lastpage}
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{\space \qquad \space}
\chead{创建函数 \qquad}
\rhead{\qquad\thepage/\pageref{LastPage}}
\begin{document}

\tableofcontents

\clearpage

\section{基本脚本函数}
\subsection{函数格式}
	函数的格式如下所示：
	\begin{lstlisting}
	# name是函数名
	# commands是组成函数的命令
	function name {
		commands
	}
	\end{lstlisting}

	函数的另一种格式如下：
	\begin{lstlisting}
	name(){
		commands
	}
	\end{lstlisting}

\subsection{使用函数}
	函数可以定义在除shell脚本第一行以外的任何位置，但是必须在函数定义处的后面使用函数。例子如下：
	\begin{lstlisting}
	#!/bin/bash
	count=1
	echo "This line comes before the function definition"

	function func1 {
		echo "This is an example of a function"
	}

	while [ $count -le 5 ]
	do
		func1
		count=$[ $count + 1 ]
	done

	echo "This is the end of the loop"
	# 在函数定义处前调用函数，将会报错
	func2
	
	function func2 {
		echo "This is an example of a function"
	}
	\end{lstlisting}

	需要注意的是，如果重复定义相同函数名的函数，将使用最新的那个函数定义，例子如下所示：
	\begin{lstlisting}
	#!/bin/bash

	function func1 {
		echo "This is the first definition of the function name"
	}

	func1

	function func1 {
		echo "This is a repeat of the same function name"
	}

	func1
	\end{lstlisting}

\section{函数返回值}
\subsection{return命令}
	bash shell将函数看作小型脚本，在默认情况下，函数的返回值是函数最后一条命令返回的退出状态。
	但是一般情况下，我们倾向于使用return命令以特定退出状态退出函数。例子如下所示：
	\begin{lstlisting}
	#!/bin/bash
	function db1 {
		read -p "Enter a value: " value
		echo "doubling the value"
		return $[ $value * 2 ]
	}

	db1
	# $?存放着函数的返回值
	echo "The new value is $?"
	\end{lstlisting}

	需要注意的是，\$?的取值范围是0～255，而且需要在函数完成后尽快提取返回值，否则在任何一条新的命令执行后，\$?将发生变化。

\subsection{使用函数输出}
	类似于用反引号获得命令的输出，我们也可以使用反引号获得函数的输出，这种方法可以从函数获取任意类型的输出并给变量赋值。例子如下：
	\begin{lstlisting}
	#!/bin/bash

	function db1 {
		read -p "Enter a value: " value
		echo $[ $value * 2 ]
	}

	result=`db1`
	echo "The new value is $result"
	\end{lstlisting}

	这个方法还可以返回浮点数和字符串值，能够比较灵活地从函数返回数据。

\section{在函数中使用变量}
\subsection{向函数传递参数}
	bash shell将函数看作小型脚本，所以可以用命令行参数的方法向函数传递参数。例子如下：
	\begin{lstlisting}
	#!/bin/bash

	function addem {
		if [ $# -eq 0 ] || [ $# -gt 2 ]
		then
			echo "-1"
		elif [ $# -eq 1 ]
		then
			echo $[ $1 + $1 ]
		else
			echo $[ $1 + $2 ]
		fi
	}

	echo -n "Adding 10 and 15: "
	value=`addem 10 15`
	echo $value

	echo -n "Let's try adding just one number: "
	value=`addem 10`
	echo $value

	echo -n "Now trying adding no numbers: "
	value=`addem`
	echo $value

	echo -n "Finally, try adding three numbers: "
	value=`addem 10 15 20`
	echo $value
	\end{lstlisting}

	需要注意的是，shell脚本中函数的命令行参数和脚本的命令行参数是相互独立的，函数无法使用脚本的命令行参数。

\subsection{在函数中处理变量}
	函数使用两种类型的变量：全局变量和局部变量。\par
	全局变量是在shell脚本中处处有效的变量，默认情况下在脚本中定义的变量就是全局变量，不管是在主代码中定义还是函数中定义。例子如下：
	\begin{lstlisting}
	#!/bin/bash

	function db1 {
		value=$[ $value * 2 ]
	}

	read -p "Enter a value: " value
	db1
	echo "The new value is: $value"
	\end{lstlisting}

	函数内部使用的变量是局部变量，需要在变量声明前面冠以local关键字，如下所示：
	\begin{lstlisting}
	local variable
	\end{lstlisting}

	局部变量的使用如下例所示：
	\begin{lstlisting}
	#!/bin/bash

	function func1 {
		local temp=$[ $value + 5 ]
		result=$[ $temp * 2 ]
	}

	temp=4
	value=6

	func1
	echo "The result is $result"
	if [ $temp -gt $value ]
	then
		echo "temp is larger"
	else
		echo "temp is smaller"
	fi
	\end{lstlisting}

\section{数组变量与函数}
\subsection{向函数传递数组}
	如果试图将数组变量作为单个参数传递，是无法正常工作的，函数只会提取数组变量的第一个取值，如下例所示：
	\begin{lstlisting}
	#!/bin/bash

	function testit {
		echo "The parameters are: $@"
		thisarray=$1
		echo "The received array is ${thisarray[*]}"
	}

	myarray={1 2 3 4 5}
	echo "The original array is: ${myarray[*]}"
	testit $myarray
	\end{lstlisting}

	为了向函数传递数组，需要将数组变量拆分为单个元素，然后使用这些元素的值作为函数参数，函数内部再将这些参数重组委新数组变量，如下例所示：
	\begin{lstlisting}
	#!/bin/bash

	function testit {
		local newarray
		newarray={`echo "$@"`}
		echo "The new array value is: ${newarray[*]}"
	}

	myarray={1 2 3 4 5}
	echo "The original array is ${myarray[*]}"
	# 向函数传递数组的正确方法
	testit ${myarray[*]}
	\end{lstlisting}

\subsection{从函数返回数组}
	函数可以使用echo语句以恰当顺序输出数组各元素的值，然后脚本必须将这些数据重组为新数组变量，如下例所示：
	\begin{lstlisting}
	#!/bin/bash

	function arraydblr {
		local origarray
		local newarray
		local elements
		local i
		origarray={`echo "$@"`}
		newarray={`echo "$@"`}
		elements=$[] $# - 1 ]
		for (( i = 0; i <= $elements; i++ ))
		do
			newarray[$i]=$[ ${origarray[$i]} * 2 ]
		done
		echo ${newarray[*]}
	}

	myarray={1 2 3 4 5}
	echo "The original array is: ${myarray[*]}"
	arg1=`echo ${myarray[*]}`
	result={`arraydblr $arg1`}
	echo "The new array is: ${result[*]}"
	\end{lstlisting}

\section{函数递归}
	递归函数的一个经典示例如下所示：
	\begin{lstlisting}
	#!/bin/bash

	function factorial {
		if [ $1 -eq 1]
		then
			echo 1
		else
			local temp=$[ $1 - 1 ]
			local result=`factorial $temp`
			echo $[ $result * $temp]
		fi
	}

	read -p "Enter value: " value
	result=`factorial $value`
	echo "The factorial of $value is: $result"
	\end{lstlisting}

\section{创建库}
	bash shell可以创建函数的库文件，然后在不同脚本中引用该库文件。\par
	首先创建库文件，如下例所示：
	\begin{lstlisting}
	# 库文件名为myfuncs
	function addem {
		echo $[ $1 + $2 ]
	}

	function multem {
		echo $[ $1 * $2 ]
	}

	function divem {
		if [ $2 -ne 0 ]
		then
			echo $[ $1 / $2 ]
		else
			echo "-1"
		fi
	}
	\end{lstlisting}

	下一步是将库文件myfuncs包含进需要调用库函数的脚本文件。可以使用source命令在shell脚本内部运行库文件脚本，这样脚本就可以使用这些函数。
	source有一个短小的别名，称为点操作符。如果想在shell脚本中调用myfuncs库文件，只需要添加如下命令行：
	\begin{lstlisting}
	. ./myfuncs
	\end{lstlisting}

	通过上述命令就可以使用库文件，如下例所示：
	\begin{lstlisting}
	#!/bin/bash
	. ./myfuncs

	value1=10
	value2=5
	result1=`addem $value1 $value2`
	result2=`multem $value1 $value2`
	result3=`divem $value1 $value2`
	echo "The result of adding them is: $result1"
	echo "The result of multiplying them is: $result2"
	echo "The result of dividing them is: $result3"
	\end{lstlisting}

\section{在.bashrc文件中定义函数}
	可以在.bashrc文件中定义函数，这样就可以在命令行中直接使用函数。可以直接在.bashrc文件的末尾添加自定义函数，如下所示：
	\begin{lstlisting}
	# .bashrc
	# ...
	function addem {
		echo ${ $1 + $2 }
	}
	\end{lstlisting}

	该函数在下一次启动新bash shell时生效。这样，该函数就可以在系统任意位置使用了。\par

	也可以将库文件的函数包含进.bashrc脚本，如下所示：
	\begin{lstlisting}
	# .bashrc
	# ...
	# 将/home/psd/libraries/myfuncs库文件包含进.bashrc文件中
	. /home/psd/libraries/myfuncs
	\end{lstlisting}
	
	当在.bashrc文件中定义函数以后，shell脚本也可以使用.bashrc文件中的函数。

\end{document}
