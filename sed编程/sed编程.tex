% !TeX spellcheck = en_US
%% 字体：方正静蕾简体
%%		 方正粗宋
\documentclass[a4paper,left=2.5cm,right=2.5cm,11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{fontspec}
\usepackage{cite}
\usepackage{xeCJK}
\usepackage{indentfirst}
\usepackage{titlesec}
\usepackage{longtable}
\usepackage{graphicx}
\usepackage{float}
\usepackage{rotating}
\usepackage{subfigure}
\usepackage{tabu}
\usepackage{amsmath}
\usepackage{setspace}
\usepackage{amsfonts}
\usepackage{appendix}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\setcounter{secnumdepth}{4}
\usepackage{mhchem}
\usepackage{multirow}
\usepackage{extarrows}
\usepackage{hyperref}
\titleformat*{\section}{\LARGE}
\renewcommand\refname{参考文献}
\renewcommand{\abstractname}{\sihao \cjkfzcs 摘{  }要}
%\titleformat{\chapter}{\centering\bfseries\huge\wryh}{}{0.7em}{}{}
%\titleformat{\section}{\LARGE\bf}{\thesection}{1em}{}{}
\titleformat{\subsection}{\Large\bfseries}{\thesubsection}{1em}{}{}
\titleformat{\subsubsection}{\large\bfseries}{\thesubsubsection}{1em}{}{}
\renewcommand{\contentsname}{{\cjkfzcs \centerline{目{  } 录}}}
\setCJKfamilyfont{cjkhwxk}{STXingkai}
\setCJKfamilyfont{cjkfzcs}{STSongti-SC-Regular}
% \setCJKfamilyfont{cjkhwxk}{华文行楷}
% \setCJKfamilyfont{cjkfzcs}{方正粗宋简体}
\newcommand*{\cjkfzcs}{\CJKfamily{cjkfzcs}}
\newcommand*{\cjkhwxk}{\CJKfamily{cjkhwxk}}
\newfontfamily\wryh{Microsoft YaHei}
\newfontfamily\hwzs{STZhongsong}
\newfontfamily\hwst{STSong}
\newfontfamily\hwfs{STFangsong}
\newfontfamily\jljt{MicrosoftYaHei}
\newfontfamily\hwxk{STXingkai}
% \newfontfamily\hwzs{华文中宋}
% \newfontfamily\hwst{华文宋体}
% \newfontfamily\hwfs{华文仿宋}
% \newfontfamily\jljt{方正静蕾简体}
% \newfontfamily\hwxk{华文行楷}
\newcommand{\verylarge}{\fontsize{60pt}{\baselineskip}\selectfont}  
\newcommand{\chuhao}{\fontsize{44.9pt}{\baselineskip}\selectfont}  
\newcommand{\xiaochu}{\fontsize{38.5pt}{\baselineskip}\selectfont}  
\newcommand{\yihao}{\fontsize{27.8pt}{\baselineskip}\selectfont}  
\newcommand{\xiaoyi}{\fontsize{25.7pt}{\baselineskip}\selectfont}  
\newcommand{\erhao}{\fontsize{23.5pt}{\baselineskip}\selectfont}  
\newcommand{\xiaoerhao}{\fontsize{19.3pt}{\baselineskip}\selectfont} 
\newcommand{\sihao}{\fontsize{14pt}{\baselineskip}\selectfont}      % 字号设置  
\newcommand{\xiaosihao}{\fontsize{12pt}{\baselineskip}\selectfont}  % 字号设置  
\newcommand{\wuhao}{\fontsize{10.5pt}{\baselineskip}\selectfont}    % 字号设置  
\newcommand{\xiaowuhao}{\fontsize{9pt}{\baselineskip}\selectfont}   % 字号设置  
\newcommand{\liuhao}{\fontsize{7.875pt}{\baselineskip}\selectfont}  % 字号设置  
\newcommand{\qihao}{\fontsize{5.25pt}{\baselineskip}\selectfont}    % 字号设置 

\usepackage{diagbox}
\usepackage{multirow}
\boldmath
\XeTeXlinebreaklocale "zh"
\XeTeXlinebreakskip = 0pt plus 1pt minus 0.1pt
\definecolor{cred}{rgb}{0.8,0.8,0.8}
\definecolor{cgreen}{rgb}{0,0.3,0}
\definecolor{cpurple}{rgb}{0.5,0,0.35}
\definecolor{cdocblue}{rgb}{0,0,0.3}
\definecolor{cdark}{rgb}{0.95,1.0,1.0}
\lstset{
	language=bash,
	numbers=left,
	numberstyle=\tiny\color{black},
	showspaces=false,
	showstringspaces=false,
	basicstyle=\scriptsize,
	keywordstyle=\color{purple},
	commentstyle=\itshape\color{cgreen},
	stringstyle=\color{blue},
	frame=lines,
	% escapeinside=``,
	extendedchars=true, 
	xleftmargin=1em,
	xrightmargin=1em, 
	backgroundcolor=\color{cred},
	aboveskip=1em,
	breaklines=true,
	tabsize=4
} 

\newfontfamily{\consolas}{Consolas}
\newfontfamily{\monaco}{Monaco}
\setmonofont[Mapping={}]{Consolas}	%英文引号之类的正常显示，相当于设置英文字体
\setsansfont{Consolas} %设置英文字体 Monaco, Consolas,  Fantasque Sans Mono
\setmainfont{Times New Roman}

\setCJKmainfont{华文中宋}


\newcommand{\fic}[1]{\begin{figure}[H]
		\center
		\includegraphics[width=0.8\textwidth]{#1}
	\end{figure}}
	
\newcommand{\sizedfic}[2]{\begin{figure}[H]
		\center
		\includegraphics[width=#1\textwidth]{#2}
	\end{figure}}

\newcommand{\codefile}[1]{\lstinputlisting{#1}}

\newcommand{\interval}{\vspace{0.5em}}

\newcommand{\tablestart}{
	\interval
	\begin{longtable}{p{2cm}p{10cm}}
	\hline}
\newcommand{\tableend}{
	\hline
	\end{longtable}
	\interval}

% 改变段间隔
\setlength{\parskip}{0.2em}
\linespread{1.1}

\usepackage{lastpage}
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{\space \qquad \space}
\chead{sed编程 \qquad}
\rhead{\qquad\thepage/\pageref{LastPage}}
\begin{document}

\tableofcontents

\clearpage

\section{sed编辑器基础知识}
\subsection{sed编辑器的介绍}
	sed编辑器又叫做流编辑器，它根据在编辑器处理数据之前事先提供的规则集来编辑数据流。\par

	sed编辑器可以根据输入命令行的命令或者存储在命令文本文件中的命令处理数据。
	它每次从输入读取一行数据，将该数据与所提供的编辑器命令进行匹配，根据命令修改数据流中的数据，然后将新数据输出到STDOUT。
	在流编辑器将全部命令和一行数据匹配完之后，它读取下一行数据，并重复上述过程。
	当处理完数据流中的全部数据行之后，流编辑器停止。\par

	使用sed命令的格式如下所示：
	\begin{lstlisting}
	sed [options] <script> <file>
	\end{lstlisting}

	script参数指定要应用于流数据的单个命令。如果需要多个命令，可以借助options参数项。\par

	options包含的命令选项如下所示：
	\begin{longtable}{p{2cm}p{7cm}}
	\hline
	-e script & 将多条命令添加到处理输入时执行的命令中 \\
	\hline
	-f file & 将文件中指定的命令添加到处理输入时执行的命令中 \\
	\hline
	-n & 不需要为每个命令产生输出，但要等待打印命令 \\
	\hline
	\end{longtable}

	需要注意的是，sed编辑器并不修改文本文件中的数据，它只是讲修改后的文本发送到STDOUT。

\subsubsection{在命令行中定义编辑器命令}
	使用单个命令处理数据的例子如下所示：
	\begin{lstlisting}
	# s命令将用第二个文本字符串替换第一个文本字符串模式
	echo "This is a test" | sed 's/test/big test/'
	# 输出为：This is a big test
	\end{lstlisting}

\subsubsection{在命令行中使用多个编辑器命令}
	如果要从sed命令行中执行多个命令，只需要使用-e选项，如下例所示：
	\begin{lstlisting}
	# data1是一个文件
	sed -e 's/brown/green/; s/dog/cat/' data1
	\end{lstlisting}

	需要注意的是，使用多个命令时，命令必须用分号隔开，而且在命令结尾和分号之间不能有任何空格。

\subsubsection{从文件读取编辑器命令}
	如果有太多的sed命令要处理，可以把它们保存在一个独立的文件中，然后在sed命令中使用-f选项指定添加文件中的命令，例子如下所示：
	\begin{lstlisting}
	# script1是存放sed命令的文件
	sed -f script1 data1
	\end{lstlisting}

	需要注意的是，文件中每一行包含一个单独的一个命令，而且不需要在每个命令后放一个分号。

\subsection{s命令的替换选项}
\subsubsection{替换标记}
	替换命令在默认情况下仅iguana各行中首次出现的文本，如果想要使用不同的替换模式，需要使用替换标记，格式如下：
	\begin{lstlisting}
	s/patter/replacement/flags
	\end{lstlisting}

	可用的替换标记如下所示：
	\begin{itemize}
		\item 数字，表示要替换的第几个模式。
		\item g，表示用新文本替换现有文本的全部实例。
		\item p，表示打印原始行的内容。
		\item w file，表示将替换的结果写入文件。
	\end{itemize}

	例子如下：
	\begin{lstlisting}
	sed 's/test/trial/g' data1
	\end{lstlisting}

\subsubsection{替换字符}
	如果要替换路径时，需要考虑到正斜杠的影响，正斜杠必须要反斜杠转义，如下例所示：
	\begin{lstlisting}
	sed 's/\/bin\/bash/\/bin\/csh/' /etc/passwd
	\end{lstlisting}

	sed编辑器允许为替换命令中的字符串定界符选择一个不同的字符，如下例所示：
	\begin{lstlisting}
	# 将“!”作为字符串定界符
	sed 's!/bin/bash!/bin/csh!' /etc/passwd
	\end{lstlisting}

\subsection{行寻址}
	如果想将sed编辑器的命令应用于某一特定的文本数据行或一组文本数据行，需要使用行寻址。
	行寻址形式有：行的数值范围和筛选行的文本模式。

\subsubsection{数字式行寻址}
	数字式行寻址的形式如下所示：
	\begin{lstlisting}
	[address]command
	\end{lstlisting}

	也可以将多个命令组合在一起，应用于一个特定的地址，如下所示：
	\begin{lstlisting}
	address {
		command1
		command2
		command3
	}
	\end{lstlisting}

	指定特定的行如下所示：
	\begin{lstlisting}
	# 指定第2行
	sed '2s/dog/cat/' data1
	\end{lstlisting}

	指定某一个范围的行如下所示：
	\begin{lstlisting}
	# 指定第2到第5行，从1开始
	sed '2,5/dog/cat/' data1
	\end{lstlisting}

	指定某一行到文本结束如下所示：
	\begin{lstlisting}
	sed '2,$s/dog/cat/' data1
	\end{lstlisting}

\subsubsection{使用文本模式来行寻址}
	使用文本模式来行寻址，格式如下：
	\begin{lstlisting}
	/pattern/command
	\end{lstlisting}

	例子如下：
	\begin{lstlisting}
	sed '/rich/s/bash/csh/' /etc/passwd
	\end{lstlisting}

\subsection{删除行命令d}
	d命令用于删除数据，一般与行寻址相配合，如下例所示：
	\begin{lstlisting}
	# 数字式行寻址
	sed '3,$d' data1
	# 文本模式行寻址
	sed '/number 1/d' data1
	\end{lstlisting}

\subsection{插入文本命令i}
	插入命令i在指定行之前添加新的一行，格式如下：
	\begin{lstlisting}
	sed '[address]i\
	new line' data1
	\end{lstlisting}

	如果没有指定行号，数据将添加在文本的最前面。

\subsection{附加文本命令a}
	附加命令a在指定行之后添加新的一行，格式如下：
	\begin{lstlisting}
	sed '[address]a\
	new line' data1
	\end{lstlisting}

	如果没有指定行号，数据将添加在文本的最后面。

\subsection{更改行命令c}
	更改行命令d格式如下：
	\begin{lstlisting}
	sed '[address]c\
	new line' data1
	\end{lstlisting}

	例子如下所示：
	\begin{lstlisting}
	# 数字式行寻址
	sed '3c\
	This is a changed line of text' data1
	# 文本模式行寻址
	sed '/number 3/c\
	This is a changed line of text' data1
	\end{lstlisting}

\subsection{变换命令y}
	变换命令y是唯一对单个字符进行操作的sed编辑器命令，格式如下：
	\begin{lstlisting}
	[address]y/inchars/outchars/
	\end{lstlisting}

	变换命令将inchars和outchars的值进行一对一映射，例子如下所示：
	\begin{lstlisting}
	echo "This 1 is a test of 1 try." | sed 'y/123/456/'
	\end{lstlisting}

\subsection{打印命令}
	打印命令p就是打印数据的原始版本，例子如下所示：
	\begin{lstlisting}
	sed '2,3p' data1
	\end{lstlisting}

	等号命令=用于打印当前行的行号，例子如下所示：
	\begin{lstlisting}
	sed '=' data1
	\end{lstlisting}

	列表命令l用于打印数据流中的文本和不可打印的ASCII字符，例子如下所示：
	\begin{lstlisting}
	sed -n 'l' data1
	\end{lstlisting}

\subsection{写文件命令w}
	写命令w如下所示：
	\begin{lstlisting}
	[address]w filename
	\end{lstlisting}

	例子如下：
	\begin{lstlisting}
	sed '1,2w test' data1
	\end{lstlisting}

\subsection{附加文件命令r}
	附加文件命令用于将某一个文件的内容附加在文件中的某一行后。
	附加文件命令r如下所示：
	\begin{lstlisting}
	[address]r filename
	\end{lstlisting}

	例子如下所示：
	\begin{lstlisting}
	sed '3r data1' data6
	\end{lstlisting}

\section{多行命令}
\subsection{next命令}
	n命令将sed编辑器移动到文本的下一行，也就是将数据流的下一行移动到sed编辑器的处理空间中，
	例子如下：
	\begin{lstlisting}
	sed '/header/{
		n
		d
	}' data1
	\end{lstlisting}

	N将数据流的下一行添加到已经存在于模式空间的文本中，这个命令适用于搜索数据文件中跨行短语的情况，如下例所示：
	\begin{lstlisting}
	sed '
		N
		s/System\nAdministrator/Desktop\nUser/
		s/System Administrator/Desktop User/
		' data1
	\end{lstlisting}

	需要注意的是，sed编辑器到达文本最后一行时，N命令因为没有下一行可以读入，所以会导致sed编辑器停止。
	所以应该将单行命令移动到N命令之前，使得多行命令在N命令之后，例子如下：
	\begin{lstlisting}
	sed '
		s/System Administrator/Desktop User/
		N
		s/System\nAdministrator/Desktop\nUser/
	' data1
	\end{lstlisting}

\subsection{多行删除命令}
	单行删除命令d会删除模式空间中的两行，多行删除命令D不同。
	在多行删除命令中，sed编辑器只删除模式空间中的第一行，例子如下：
	\begin{lstlisting}
	sed '
		N
		/System\nAdministrator/d
	' data1

	sed '
		N
		/System\nAdministrator/D
	'
	\end{lstlisting}

\subsection{多行打印命令}
	单行打印命令p会打印模式空间中的两行，而多行打印命令P不同。
	在多行打印命令中，sed编辑器只打印模式空间中的第一行，例子如下：
	\begin{lstlisting}
	sed -n '
		N
		/System\nAdministrator/P
	' data1
	\end{lstlisting}

\section{保留空间}
	模式空间是sed编辑器处理命令时保留的文本，而保留空间是在处理模式空间中的其他行时，可以使用保留空间暂时保留文本行。\par

	sed编辑器保留空间相关的命令：
	\begin{longtable}{p{2cm}p{6cm}}
	\hline
	h & 将模式空间复制到保留空间 \\
	\hline
	H & 将模式空间追加到保留空间 \\
	\hline
	g & 将保留空间复制到模式空间 \\
	\hline
	G & 将保留空间追加到模式空间 \\
	\hline
	x & 将模式空间和保留空间的内容变换 \\
	\hline
	\end{longtable}

	需要注意的是，不管是复制还是追加，都不会把源数据空间的内容清空。\par

	例子如下：
	\begin{lstlisting}
	sed -n '/first/{
		h
		p
		n
		p
		g
		p
	}'
	\end{lstlisting}

\section{否定命令}
	感叹号命令!用于否定命令，也就是在命令被激活的地方不激活命令，在命令不被激活的地方激活命令，例子如下：
	\begin{lstlisting}
	sed -n '/header/!p' data1
	\end{lstlisting}

	否定命令可以用于饭庄数据流中的文本行的顺序，算法如下：
	\begin{itemize}
		\item[1.] 将一行放到保留空间中。
		\item[2.] 将文本的下一行放到模式空间中。
		\item[3.] 将保留空间追加到模式空间。
		\item[4.] 将模式空间放到保留空间。
		\item[5.] 重复第2步到第4步，直至所有行以相反的顺序放到保留空间。
		\item[6.] 检索行并打印它们。
	\end{itemize}

\section{更改命令流}
\subsection{分支命令}
	分支命令可以指定地址不去执行脚本命令。
	分支命令的格式如下：
	\begin{lstlisting}
	[address]b [label]
	\end{lstlisting}

	address参数决定哪个行或哪些行激活分支命令，label参数定义了分支的标签，使用标签可以跳过与分支地址匹配的命令，而仍然执行脚本中的其他命令。
	如果label参数不存在，则分支命令将继续执行到脚本的结尾，也就是整个脚本的命令都不执行。例子如下：
	\begin{lstlisting}
	sed '{
		/first/b jump1
		s/ is/ might be/
		s/line/test/
		:jump1
		s/data/text/
	}' data1
	\end{lstlisting}
	
	需要注意的是，如果没有恰当地指定address参数，可能会导致死循环，例子如下：
	\begin{lstlisting}
	echo "This, is, a, test, to, remove, commas." | sed -n '{
		:start
		s/,//1p
		b start
	}'
	\end{lstlisting}

\subsection{测试命令}
	测试命令是基于替换命令的结果跳转到标签。
	如果替换命令成功匹配并替换了一个模式，则测试命令分支到指定的标签。如果替换命令不匹配指定的模式，则测试命令不分支。
	测试命令的格式如下：
	\begin{lstlisting}
	[address]t [label]
	\end{lstlisting}

	address指定测试命令作用的地址范围。如果不指定标签label，测试成功时将分支到脚本的最后，也就是不执行整个脚本。
	测试命令可以实现if-then语句功能，如果一个替换命令成功，则另一个替换命令则不需要在执行，例子如下：
	\begin{lstlisting}
	sed '{
		s/first/starting/
		t
		s/line/test/
	}' data1
	\end{lstlisting}

	测试命令还可以实现for循环的功能，例子如下：
	\begin{lstlisting}
	echo  "This, is, a, test, to, remove, commas." | sed -n '{
		:start
		s/,//1p
		t start
	}'
	\end{lstlisting}

\section{模式替换}
	现在面临的情况是，我们在使用替换命令时，使用通配符可以匹配任意单词，但是替换字符串不能以通配符的值替换匹配的单词。
	例子如下：
	\begin{lstlisting}
	echo "The cat sleeps in his hat." | sed 's/.at/".at"/g'
	\end{lstlisting}

\subsection{与号\&}
	与号\&表示替换命令中的匹配模式，例子如下：
	\begin{lstlisting}
	echo "The cat sleeps in his hat." | sed 's/.at/"&"/g'
	\end{lstlisting}

\subsection{替换个别单词}
	模式匹配中匹配的是整个字符串，但有时候我们只想要匹配模式中的子集。
	sed编辑器使用圆括号定义替换模式中的子字符串，然后用特定的符号引用子字符串元素。
	特定的符号由反斜杠和数字组成，第一个元素分配为字符$\backslash$1，第二个元素分配为字符$\backslash$2，依次类推。
	需要注意的是，在替换命令中使用圆括号时，必须在圆括号前加转义符号。例子如下：
	\begin{lstlisting}
	echo "The System Administrator manual" | sed 's/\(System\) Administrator/\1 User/'
	\end{lstlisting}

\section{在脚本中使用sed}
\subsection{使用包装器}
	在shell脚本中，可以在sed编辑器脚本中使用常规的shell变量和参数，例子如下：
	\begin{lstlisting}
	#!/bin/bash
	# 文件名是reverse
	sed -n '{
		1!G
		h
		$p
	}' "$1"
	# $1是命令行参数
	\end{lstlisting}

	使用这个脚本和使用正常的shell脚本一样，例子如下：
	\begin{lstlisting}
	# reverse是sed编辑器脚本的文件名
	./reverse data1
	\end{lstlisting}

\subsection{重定向sed输出}
	可以使用反引号将sed编辑器命令的输出重定向到一个变量，例子如下：
	\begin{lstlisting}
	#!/bin/bash

	factorial=1
	counter=1
	number=$1

	while [ $counter -le $number ]
	do
		factorial=$[ $factorial * $counter ]
		$counter=$[ $counter + 1 ]
	done

	result=`echo $factorial | sed '{
	:start
	s/\(.*[0-9]\)\([0-9]\{3\}\)/\1,\2/
	t start
	}'`

	echo "The result is $result"
	\end{lstlisting}

\end{document}
